#pragma config(Motor,  port6,           leftWheel,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightWheel,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           flipperRight,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           flipperLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port2,           armLeft,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           armRight,       tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//************************
//         CONFIG
//************************
//#pragma platform(VEX2);
//#pragma competitionControl(Competition)
//#include "Vex_Competition_Includes.c"


//************************
//       VARIABLES
//************************
//bool bStopTasksBetweenModes = true;
//*************************
//         METHODS
//*************************

/***** MOVEMENT *****/

/* Move the robot forward/backward
		wheelPower: [-127, 127] how fast the robot goes
				(+) => forwards
				(-) => backwards      */
void moveWheels(int wheelPower) {
	motor[leftWheel] = -wheelPower;
	motor[rightWheel] = wheelPower-1; //dont change! made so robot does not curve
}

/* Stops all wheel movement */
void stopWheels() {
	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
}

/* Turns 180 counterclockwise */
void turnLeft() {
	motor[leftWheel] = -60;
	motor[rightWheel] = -60;
	sleep(2750);
	stopWheels();
}

/* Turns 180 clockwise */
void turnRight() {
	motor[leftWheel] = 60;
	motor[rightWheel] = 60;
	sleep(2750);
	stopWheels();
}


/* uses controller values to update wheels through tank driving */
void updateWheelsTANK() {
	motor[leftWheel] = -(vexRT[Ch3])/3;
	motor[rightWheel] = (vexRT[Ch2])/3;
}

/* uses controller values to update wheels through normal driving. it should be noted that the y 
is currently weighted more to emphasize forward movement over horizontal.*/
void updateWheelsChassis() {
 motor[leftMotor]  = (1.5*vexRT[Ch2] + vexRT[Ch1])/2.5;  
 motor[rightMotor] = (1.5*vexRT[Ch2] - vexRT[Ch1])/2.5;  
}

//***** FLIPPER *****

/*lifts the arm by spinning both motors at the same speed in the same direction*/
void moveArmUp(){
  motor[armLeft] = 60;//
	motor[armRight] = 60;
	sleep(2750);
}

/*lowers the arm by spinning both motors at the same speed in the same direction*/
void moveArmDown(){
  motor[armLeft] = 60;
	motor[armRight] = 60;
	sleep(2750);
}

/*brings blocks by spinning both motors at the same speed in different directions*/
void bringBlockIntoArm(){
  motor[armLeft] = 60;//
	motor[armRight] = -60;
	sleep(2750);
}

/*removes blocks by spinning both motors at the same speed in different directions*/
void bringBlockIntoArm(){
  motor[armLeft] = 60;//
	motor[armRight] = -60;
	sleep(2750);
}

/*updates arms using preset values*/
void updateArm() {
	if(vexRT[Btn5U] == 1){ // If upper Z button down
		moveArmUp();
		}
	else if(vexRT[Btn5D] == 1){ // If lower Z button down
		moveArmDown();
		}
  else if(vexRT[Btn6U] == 1){
    bringBlockIntoArm();
    }
  else if(vexRt[Btn6D] == 1){
    takeBlockOutOfArm();
    }
	else{
		motor[armLeft] = 0;
		motor[armRight] = 0;
    sleep(2750);
	}
}

/*updates arms using controller values*/
void updateArm2() {
	
}

void autonomous(){
}

task main(){
  updateArm();
  updateWheels2();
}
